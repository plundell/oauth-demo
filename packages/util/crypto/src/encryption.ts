/**
 * @module @local/util-crypto/encryption
 * 
 * This module contains function to encrypt and decrypt data, using 
 * public or private key in either order. Keys must be in PEM format
 * and can be generated by the {@link @local/util-crypto/keys} module.
 * 
 * @export type {@link EncryptableData} - Any Serializable JSON Value can be encrypted
 * @export {@link encrypt} - Encrypts data using a public or private key.
 * @export {@link decrypt} - Decrypt data using a public or private key.
 */
import * as crypto from 'crypto';
import BUG from '@local/util-errors/BUG';
import { JSONValue, typedParse } from '@local/util-vars/json';
import jwt from 'jsonwebtoken';


/**
 * Any Serializable JSON Value can be encrypted (ie. not a function, symbol or bigint)
 */
export type EncryptableData = JSONValue;

/**
 * Encrypts some data using a public or private key. 
 * 
 * NOTE: that the opposite key must be used with {@link decrypt()}.
 * 
 * @param data - The data to be encrypted. Can be a string, number, or object.
 * @param key - The contents of a private or public key file to use for encryption. 
 * 
 * @returns The encrypted data as a base64 string.
 */
export function encrypt(data: EncryptableData, key: string): string {
	try {
		if (typeof data !== 'string' && typeof data !== 'number' && typeof data !== 'object') {
			throw new Error('Data must be a string, number, or object. Got type: ' + typeof data);
		}

		//Start by serializing the data and turning it into a buffer...
		const jsonData = JSON.stringify(data);
		const bufferData = Buffer.from(jsonData, 'utf8');

		//Apparently node cares if you're encrypting with the private or public key... cool
		const fn = key.includes('PRIVATE KEY') ? crypto.privateEncrypt : crypto.publicEncrypt;

		//...then encrypt the buffer...
		const encryptedBuffer = fn(
			{
				key,
				padding: crypto.constants.RSA_PKCS1_PADDING,
			},
			bufferData
		);

		//...and finally return it as a base64 string
		return encryptedBuffer.toString('base64');
	} catch (e) {
		console.error("Failed to encrypt this data:\n", data);
		throw new Error(`Failed to encrypt data. See log for details.`, { cause: e });
	}
}

/**
 * Decrypt data with a private or public key. 
 * 
 * **NOTE**: use the opposite key from what you used with  {@link encrypt()}.
 * 
 * @template T The expected format of the decrypted data which is returned. 
 * 
 * @param encryptedBase64 - The encrypted data as a base64 string.
 * @param key - The contents of a private or public key file to use for decryption. 
 * @param validator - An optional function to validate the decrypted data (whatever it 
 *                      returns or throws will be returned or thrown from this function).
 * 
 * @returns The encrypted data as a base64 string.
 */
export function decrypt<T extends EncryptableData>(
	encryptedBase64: string, key: string, validator?: (raw: unknown) => T): T {
	//Turn the passed in data into a buffer
	const encryptedBuffer = Buffer.from(encryptedBase64, 'base64');

	//Pick which decrypt function to use based on which type of key was passed in
	const fn = key.includes('PRIVATE KEY') ? crypto.privateDecrypt : crypto.publicDecrypt;

	//Decrypt the data...
	try {
		var decryptedBuffer = fn(
			{
				key,
				padding: crypto.constants.RSA_PKCS1_PADDING,
			},
			encryptedBuffer
		);
	} catch (cause) {
		throw new Error(`Failed to decrypt with the given key meaning this `
			+ `data wasn't encrypted by us or has been tampered with.`, { cause });
	}
	try {
		//...and parse it into whatever type we're expecting it to be, which we return
		const decryptedJson = decryptedBuffer.toString('utf8');
		var data = typedParse(decryptedJson);
	} catch (cause) {
		throw new BUG(`Managed to decrypt the data, but failed to parse it as ` +
			`JSON which means the encryption key has been used somewhere other ` +
			`than this module.`, cause);
	}

	if (validator)
		return validator(data);
	else
		return data as T;
	//NOTE: that we DO NOT actually check that the object is the right type
}

/**
 * Sign data using JWT with either a private or public key.
 * 
 * @template T The type of data being signed
 * 
 * @param data - The data to sign. Must be a plain object or array that can be serialized to JSON.
 * @param key - The contents of a private or public key file to use for signing.
 * @param options - Optional JWT sign options (like expiresIn, algorithm etc)
 * 
 * @returns A JWT string containing the signed data
 * 
 * @throws {Error} If signing fails or if data cannot be serialized
 */
export function sign<T extends EncryptableData>(
	data: T,
	key: string,
	expiresIn: number
): string {

	try {
		const options: jwt.SignOptions = {
			algorithm: key.includes('PRIVATE KEY') ? 'RS256' : 'PS256',
		}

		// Default to RS256 algorithm for RSA keys
		const jsonData = JSON.stringify(data);
		const bufferData = Buffer.from(jsonData, 'utf8');

		// Sign the data using jsonwebtoken
		return jwt.sign(bufferData, key, options);
	} catch (cause) {
		throw new Error('Failed to sign data with the given key', { cause });
	}
}

/**
 * Verify and decode a JWT token that was signed with sign().
 * 
 * **NOTE**: use the opposite key from what you used with {@link sign()}.
 * 
 * @template T The expected format of the decoded data which is returned
 * 
 * @param token - The JWT string to verify and decode
 * @param key - The contents of a private or public key file to use for verification
 * @param validator - Optional function to validate the decoded data (whatever it
 *                   returns or throws will be returned or thrown from this function)
 * @param options - Optional JWT verify options
 * 
 * @returns The decoded data from the JWT
 * 
 * @throws {Error} If verification fails or if token is invalid
 */
export function verify<T extends EncryptableData>(
	token: string,
	key: string,
	validator?: (raw: unknown) => T,
): T {
	try {
		// Verify and decode the token
		const decoded = jwt.verify(token, key, { algorithms: ['RS256', 'PS256'] }); // Accept both RSA algorithms

		// Run the validator if provided
		if (validator) {
			return validator(decoded);
		}

		return decoded as T;
		//NOTE: like decrypt(), we don't actually verify the type matches T
	} catch (cause) {
		if (cause instanceof jwt.JsonWebTokenError) {
			throw new Error('Token verification failed - token may be invalid or tampered with', { cause });
		}
		if (cause instanceof jwt.TokenExpiredError) {
			throw new Error('Token has expired', { cause });
		}
		throw new Error('Failed to verify token', { cause });
	}
}
